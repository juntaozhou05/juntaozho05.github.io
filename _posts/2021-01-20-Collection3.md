---
layout: post
title: "算法总结3-动态规划"
subtitle: ""
author: "ZJT"
header-style: text
tags:
  - js
---

1.买卖股票的最佳时机

给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

思路：
循环版
暴力循环，i 为卖出的天数，j 为买入的天数。

i 从 1 开始，因为第 0 天不可能卖出。

j 从 0 开始到 i 结束，因为买入的天数一定小于卖出的天数。

然后在这两者间的差价中找最大值。

解答：
```
let maxProfit = function (prices) {
  let max = 0;
  for(let i = 1; i < prices.length; i++) {
    for(let j = 0; j < i; j++) {
      let price = prices[j];
      let sale = prices[i] - price;
      max = Math.max(max, sale);
    }
  }
  return max;
}
```

动态规划版
状态转移方程是

当天的最大收益 = max(
  当天卖出：当天的价格 - 过去几天最低的价格,
  当天不卖：过去几天的最大收益
)

解答：
```
const maxProfit = (prices) => {
  let n = prices.length;
  if(!n || n === 1) return 0;

  let max = 0;
  let min = prices[0];

  for(let i = 0; i < n; i++) {
    let price = prices[i];

    max = Math.max(price - min, max);
    min = Math.min(price, min);
  }
  return max;
}

```

2.爬楼梯
假设你正在爬楼梯。需要 n  阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1 阶 + 1 阶
2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1 阶 + 1 阶 + 1 阶
1 阶 + 2 阶
2 阶 + 1 阶

思路：
这题的思路是，对于到达任意一个阶梯 n，都可以分为「从前两个台阶跨两步到达」和「从前一个台阶跨一步到达」，而本题的目的是取「方式之和」，所以动态规划的状态转移方程是
dp[n] = dp[n - 1] + dp[n - 2]

从上一阶的位置跨一步，取 dp[i - 1]的到达方式数量。
从上两阶的位置跨两步，取 dp[i - 2]的到达方式数量。
然后把这两个方式的数量相加，就是到达第 n 阶的方式总数。

解答：
```
const climbStairs = (n) => {
  let dp = [];

  dp[1] = 1;
  dp[2] = 2;

  for(let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}
```

3.最小路径和
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。

思路
找状态转移方程
首先这题要想清楚的一点是，到达了一个格子只有两种可能：

从左边来。
从上边来。
有了这个思路，状态转移方程其实就可以定义出来了：dp[i] = min(dp[left], dp[top])

找基础状态
其实第一行和第一列都是基础状态，第一行的格子只有可能从左边过来，而第一列的格子只可能从上面过来。

解答
```

```

4.背包问题
有{n}n件物品和{1}1个容量为W的背包。每种物品均只有一件，第{i}i件物品的重量为{weights[i]}weights[i]，价值为{values[i]}values[i]，求解将哪些物品装入背包可使价值总和最大。

解答：
```
function knapsack(weights, values, W){
  var n = weights.length -1
  var f = [[]]
  for(var j = 0; j <= W; j++){
      if(j < weights[0]){ //如果容量不能放下物品0的重量，那么价值为0
         f[0][j] = 0
      }else{ //否则等于物体0的价值
         f[0][j] = values[0]
      }
  }
  for(var j = 0; j <= W; j++){
      for(var i = 1; i <= n; i++ ){
          if(!f[i]){ //创建新一行
              f[i] = []
          }
          if(j < weights[i]){ //等于之前的最优值
              f[i][j] = f[i-1][j]
          }else{
              f[i][j] = Math.max(f[i-1][j], f[i-1][j-weights[i]] + values[i]) 
          }
      }
  }
  return f[n][W]
}
```












          


























