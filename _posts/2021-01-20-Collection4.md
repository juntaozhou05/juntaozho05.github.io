---
layout: post
title: "算法总结3-动态规划"
subtitle: ""
author: "ZJT"
header-style: text
tags:
  - js
---

1.买卖股票的最佳时机

给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

思路：
循环版
暴力循环，i 为卖出的天数，j 为买入的天数。

i 从 1 开始，因为第 0 天不可能卖出。

j 从 0 开始到 i 结束，因为买入的天数一定小于卖出的天数。

然后在这两者间的差价中找最大值。

解答：
```
let maxProfit = function (prices) {
  let max = 0;
  for(let i = 1; i < prices.length; i++) {
    for(let j = 0; j < i; j++) {
      let price = prices[j];
      let sale = prices[i] - price;
      max = Math.max(max, sale);
    }
  }
  return max;
}
```

动态规划版
状态转移方程是

当天的最大收益 = max(
  当天卖出：当天的价格 - 过去几天最低的价格,
  当天不卖：过去几天的最大收益
)

解答：
```
const maxProfit = (prices) => {
  let n = prices.length;
  if(!n || n === 1) return 0;

  let max = 0;
  let min = prices[0];

  for(let i = 0; i < n; i++) {
    let price = prices[i];

    max = Math.max(price - min, max);
    min = Math.min(price, min);
  }
  return max;
}

```

2.爬楼梯
假设你正在爬楼梯。需要 n  阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1 阶 + 1 阶
2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1 阶 + 1 阶 + 1 阶
1 阶 + 2 阶
2 阶 + 1 阶

思路：
这题的思路是，对于到达任意一个阶梯 n，都可以分为「从前两个台阶跨两步到达」和「从前一个台阶跨一步到达」，而本题的目的是取「方式之和」，所以动态规划的状态转移方程是
dp[n] = dp[n - 1] + dp[n - 2]

从上一阶的位置跨一步，取 dp[i - 1]的到达方式数量。
从上两阶的位置跨两步，取 dp[i - 2]的到达方式数量。
然后把这两个方式的数量相加，就是到达第 n 阶的方式总数。

解答：
```
const climbStairs = (n) => {
  let dp = [];

  dp[1] = 1;
  dp[2] = 2;

  for(let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}
```

3.最小路径和
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。

思路
找状态转移方程
首先这题要想清楚的一点是，到达了一个格子只有两种可能：

从左边来。
从上边来。
有了这个思路，状态转移方程其实就可以定义出来了：dp[i] = min(dp[left], dp[top])

找基础状态
其实第一行和第一列都是基础状态，第一行的格子只有可能从左边过来，而第一列的格子只可能从上面过来。

解答
```

```

4.背包问题
有{n}n件物品和{1}1个容量为W的背包。每种物品均只有一件，第{i}i件物品的重量为{weights[i]}weights[i]，价值为{values[i]}values[i]，求解将哪些物品装入背包可使价值总和最大。

解答：
```
function knapsack(weights, values, W){
  var n = weights.length -1
  var f = [[]]
  for(var j = 0; j <= W; j++){
      if(j < weights[0]){ //如果容量不能放下物品0的重量，那么价值为0
         f[0][j] = 0
      }else{ //否则等于物体0的价值
         f[0][j] = values[0]
      }
  }
  for(var j = 0; j <= W; j++){
      for(var i = 1; i <= n; i++ ){
          if(!f[i]){ //创建新一行
              f[i] = []
          }
          if(j < weights[i]){ //等于之前的最优值
              f[i][j] = f[i-1][j]
          }else{
              f[i][j] = Math.max(f[i-1][j], f[i-1][j-weights[i]] + values[i]) 
          }
      }
  }
  return f[n][W]
}
```

5.三角形最小路径和
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]

自顶向下的最小路径和为  11（即，2 + 3 + 5 + 1 = 11）。

思路：
上一层的某个 index 的最小值是由下一层的两个相邻节点的最小值所决定的。

那么先从最后一行开始求每一个下标所对应的最小路径，也就是最后一行每个下标本身的值，作为基础状态，然后向上面的行求解即可。
```
dp[level][index] = min(
   indexVal + dp[level + 1][index],
   indexVal + dp[level + 1][index + 1],
)
```

解答：
```
let minimumTotal = function (triangle) {
  let dp = []
  let n = triangle.length
  if (!n) {
    return 0
  }

  dp[n - 1] = triangle[n - 1]

  for (let i = n - 2; i >= 0; i--) {
    dp[i] = []
    let row = triangle[i]
    for (let j = 0; j < row.length; j++) {
      let curVal = row[j]
      dp[i][j] = Math.min(
        // 选择下一层同下标
        curVal + dp[i + 1][j],
        // 选择下一层next下标
        curVal + dp[i + 1][j + 1]
      )
    }
  }

  return dp[0][0]
}
```

6.最长公共子序列
给定两个字符串  text1 和  text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

示例 1:

输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。
示例 2:

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
示例 3:

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
 

提示:

1 <= text1.length <= 1000
1 <= text2.length <= 1000
输入的字符串只含有小写英文字符。

思路：
把两个字符长度都置为 1 开始规划基础状态，注意这是一个二维的 dp 数组, dp[m][n] 中的 m 和 n 分别代表字符串 1 的长度和字符串 2 的长度，这个坐标的状态就是「字符串 1 长度为 m 且字符串 2 长度为 n 时的最长公共序列长度」。

对于 dp[m][n] 来说，分为两种情况：

s1[m] === s2[n] 字符相等，那么就直接等于 1 + dp[m - 1][n - 1]，也就是当前相等所得到的长度 1 加上两个字符各减去一位后的最长子序列长度。

s1[m] !== s2[n] 字符不相等，那么就分别尝试把两边各减去一位，求它们的最长子序列长度中的 最大值，也就是 max(dp[m][n - 1], dp[m - 1][n])。

解答：
```
let longestCommonSubsequence = function (text1, text2) {
  let n1 = text1.length
  let n2 = text2.length

  let dp = []

  for (let i1 = 0; i1 <= n1; i1++) {
      dp[i1] = []
      dp[i1][0] = 0
  }
  dp[0] = Array(n2 + 1).fill(0)

  for (let i1 = 1; i1 <= n1; i1++) {
      for (let i2 = 1; i2 <= n2; i2++) {
          let str1 = text1[i1 - 1]
          let str2 = text2[i2 - 1]

          if (str1 === str2) {
              dp[i1][i2] = 1 + dp[i1 - 1][i2 - 1]
          }else {
              dp[i1][i2] = Math.max(dp[i1 - 1][i2], dp[i1][i2 - 1])
          }
      }
  }

  return dp[n1][n2]
};
```

7.一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？

思路：
步骤一、定义数组元素的含义
由于我们的目的是从左上角到右下角一共有多少种路径，那我们就定义 dp[i] [j]的含义为：当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径。那么，dp[m-1] [n-1] 就是我们要的答案了。

注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是我们要找的答案。
步骤二：找出关系数组元素间的关系式
想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达

一种是从 (i-1, j) 这个位置走一步到达

一种是从(i, j - 1) 这个位置走一步到达

因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]。

步骤三、找出初始值
显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：

dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往左走

dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走

解答：
```
const uniquePaths = (m, n) => {
	if( m<= 0 || n <= 0) {
			return 0;
	}

	let dp = [];

	for(let i = 0; i < m; i++) {
		dp[i] = [];
		dp[i][0] = 1;
	}
	for(let i = 0; i < n; i++) {
		dp[0][i] = 1;
	}

	for(let i = 1; i < m; i++) {
		for(let j = 1; j < n; j++) {
			dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
		}
	}
	return dp[m - 1][n -1];
}
```
          
8.给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
举例：
输入:
arr = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。

思路：步骤一、定义数组元素的含义
由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp[i] [j]的含义为：当机器人从左上角走到(i, j) 这个位置时，最下的路径和是 dp[i] [j]。那么，dp[m-1] [n-1] 就是我们要的答案了。

注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 由下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是我们要走的答案。
步骤二：找出关系数组元素间的关系式
想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达

一种是从 (i-1, j) 这个位置走一步到达

一种是从(i, j - 1) 这个位置走一步到达

不过这次不是计算所有可能路径，而是计算哪一个路径和是最小的，那么我们要从这两种方式中，选择一种，使得dp[i] [j] 的值是最小的，显然有

dp[i] [j] = min(dp[i-1][j]，dp[i][j-1]) + arr[i][j];// arr[i][j] 表示网格种的值
步骤三、找出初始值
显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：

dp[0] [j] = arr[0] [j] + dp[0] [j-1]; // 相当于最上面一行，机器人只能一直往左走

dp[i] [0] = arr[i] [0] + dp[i] [0]; // 相当于最左面一列，机器人只能一直往下走

解答：
```
const uniquePaths = (arr) => {
	const m = arr.length;
	const n = arr[0].length;
	if(m <= 0 || n <= 0) {
		return 0;
	}

	const dp = [];
	dp[0] = [];
	// 初始化
	dp[0][0] = arr[0][0];
	// 初始化最上边的行
	for(let i = 1; i< m; i++) {
		dp[i] = [];
		dp[i][0] = dp[i - 1][0] + arr[i][0];
	}
	// 初始化最上边的行
	for(let i = 1; i < n; i++){
		dp[0][i] = dp[0][i-1] + arr[0][i];
	}
	// 推导出 dp[m-1][n-1]
	for (let i = 1; i < m; i++) {
		for (let j = 1; j < n; j++) {
				dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + arr[i][j];
		}
	}
		return dp[m-1][n-1];
}
```

9.


































