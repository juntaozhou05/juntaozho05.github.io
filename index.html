<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Juntao Zhou Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="imgs/logo.ico">
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/index.css">
  </head>
  <body>
      <div class="logo">
        <div class="contaienr">
          <div class="logo-info">
            <a href="index.html">
              <h2><img src="img/logo.ico" alt="">Zhou Juntao Blog</h2>
            </a>
          </div>
        </div>
      </div>
      <div class="menu">
         <nav class="navbar navbar-default">
           <div class="container">
             <button type="buuton" class="navbar-toggle" data-toggle="collapse" data-target="#menus">Menu</button>
           </div>
           <div class="navbar-collapse collapse" id="menus">
             <ul class="nav navbar-nav">
               <li class="bounce-bottom active">
                  <a href="index.html">博客</a>
               </li>
               <li class="bounce-bottom">
                  <a href="index.html">作品</a>
               </li>
               <li class="bounce-bottom">
                  <a href="index.html">github</a>
               </li>
               <li class="bounce-bottom">
                  <a href="index.html">关于</a>
               </li>
             </ul>
           </div>
         </nav>
      </div>

      <div class="container" id="main">
          <div class="row">
            <ul id="pageMain">
                <li class="col-xs-12">
                  <a href="">
                    <p class="blogtitle"><span>web前端命名规范</span><span class="time">2016-10-20</span></p>
                    <p class="blogcontent">一个好的前端项目代码离不开好的命名规范，试想一下叫你接手一个项目，你看到之前开发的代码的命名一团糟，那是多么痛苦的事啊。或者你自己把一个项目命名的一团糟，等过段时间让你重构该项目的时候，估计肠子都要悔青吧！
                    前端web开发命名规范</p>
                  </a>
                </li>
                <li class="col-xs-12">
                    <a href="">
                    <p class="blogtitle"><span>为什么JavaScript是单线程的却能让AJAX异步？</span><span class="time">2016-10-14</span></p>
                    <p class="blogcontent">默认情况javascript是同步加载的,javascript的加载时阻塞时，后面的元素要等待javascript加载完毕后才能进行再加载。
            浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如mouse click, a timer firing, or an XMLHttpRequest </p>
                  </a>
                </li>
                <li class="col-xs-12">
                    <a href="">
                    <p class="blogtitle"><span>响应式核心之媒体查询</span><span class="time">2016-09-05</span></p>
                    <p class="blogcontent">响应式的核心非媒体查询莫属了，而媒体查询用的最多的还是浏览器尺寸查询，这里就总结一下尺寸媒体查询用法
            首先设置《meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, </p>
                  </a>
                </li>
                <li class="col-xs-12">
                    <a href="">
                    <p class="blogtitle"><span>JavaScript常用函数和方法</span><span class="time">2016-08-10</span></p>
                    <p class="blogcontent">JavaScript常用函数和方法： 1.处理小数点问题： 1.丢弃小数部分,保留整数部分   js:parseInt(9/2)   
              2.向上取整,有小数就整数部分加1    js: Math.ceil(9/2)   3,四舍五入.   js: Math.round(9/2)   
              4,向下取整    js: Math.floor(9/2) 2.判断滚轮滚动动作 </p>
                  </a>
                </li>
                <li class="col-xs-12">
                    <a href="">
                    <p class="blogtitle"><span>超级实用的41条JS技巧(转)</span><span class="time">2016-07-20</span></p>
                    <p class="blogcontent">1.  将彻底屏蔽鼠标右键
              oncontextmenu=”window.event.returnValue=false”
              < table border oncontextmenu=return(false)>< td>no< /table> 可用于 Table
              2.  取消选取、防止复制
              < body onselectstart=”return false”>
              3.JS不允许粘贴
              onpaste=”return false”
              4. JS防止复制
              oncopy=”return false;” oncut=”return false;”
              5. IE 地址栏前换成自己的图标
              < link rel=”Shortcut Icon” href=”favicon.ico”>
              在文件的根目录放进去这个图片 </p>
                  </a>
                </li>
                <li class="col-xs-12">
                    <a href="">
                    <p class="blogtitle"><span>常见的web性能优化方法(转)</span><span class="time">2016-06-06</span></p>
                    <p class="blogcontent">
              前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，前端优化的目的是什么 ?
　         　1. 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。
　         　2. 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。
　         　总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。 </p>
                  </a>
                </li>

                <li class="col-xs-12">
                    <a href="">
                    <p class="blogtitle"><span>JavaScript常用的获取各个元素宽度和高度(转)</span><span class="time">2016-05-14</span></p>
                    <p class="blogcontent">
              这里总结一下JavaScript常用的获取各个元素宽度和高度的一些方法：
            1.document.body.clientWidth - 网页可见区域宽
               document.body.clientHeight - 网页可见区域高
            2.document.body.offsetWidth - 网页可见区域宽，包括边线和滚动条的宽
               document.body.offsetHeight - 网页可见区域高，包括边线和滚动条的高
            3.document.body.scrollWidth - 网页总宽
               document.body.scrollHeight - 网页总高 </p>
                  </a>
                </li>
                <li class="col-xs-12">
                    <a href="blogs/blog2.html">
                    <p class="blogtitle"><span>css盒子模型总结(转)</span><span class="time">2016-04-14</span></p>
                    <p class="blogcontent">
              css盒子模型分为IE盒子模型和“W3C”标准盒子模型。我们一般都是使用的“W3C”标准盒子模型。所以这里就只介绍“W3C”标准盒子模型
              css盒子模型一共分为五层，从上到下分别是：
              边框（border），位于盒子的第一层。
              元素内容（content）、内边距（padding），两者同位于第二层。
              背景图（background-image），位于第三层。
              背景色（background-color），位于第四层。
              整个盒子的外边距（margin），位于第五层... </p>
                  </a>
                </li>
                <li class="col-xs-12">
                    <a href="blogs/blog1.html">
                    <p class="blogtitle"><span>js中的call及apply</span><span class="time">2016-02-29</span></p>
                    <p class="blogcontent">
              call([thisObj[,arg1[, arg2[, [,.argN]]]]])：调用一个对象的一个方法，以另一个对象替换当前对象。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。
              apply([thisObj[,argArray]])：应用某一对象的一个方法，用另一个对象替换当前对象。 apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。
              他们都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</p>
                  </a>
                </li>

            </ul>
          </div>
      </div>


      <div id="pageBox">
        <span id="prev">上一页</span>
          <ul id="pageNav">
          </ul>
          <span id="next">下一页</span>
      </div>

      <footer>
        <p>Author by Zhou Juntao @2016</p>
      </footer>

  </body>
  <script src="js/jquery.min.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <script>
    tabPage({
      pageMain : 'pageMain',
      pageNav : 'pageNav',
      pagePrev: 'prev',
      pageNext: 'next',
      curNum: 4,      //每页显示的条数
      activeClass: 'active',   //高光显示的class
      ini: 0    //初始化显示的页面
    });

    function tabPage(tabPage){
      var pageMain = document.getElementById(tabPage.pageMain);   //获取内容列表
      var pageNav = document.getElementById(tabPage.pageNav);     //获取分页
      var pagePrev = document.getElementById(tabPage.pagePrev);   //上一页
      var pageNext = document.getElementById(tabPage.pageNext);   //下一页
      
      var curNum = tabPage.curNum;                                //每页显示数
      var len = Math.ceil(pageMain.children.length / curNum);     //计算总页数
      var pageList = '';                                          //生成页码
      var iNum = 0;                                               //当前的索引值index
      
      for(var i = 0; i < len; i++){
        pageList+='<a href="javascript:;">'+ ( i + 1)+'</a>';
      }
      pageNav.innerHTML = pageList;
      
      pageNav.children[0].className = tabPage.activeClass;        //头一页加高亮显示
      
      for(var i = 0; i < pageNav.children.length; i++){
        pageNav.children[i].index = i;
        pageNav.children[i].onclick = function(){
          for(var t = 0; t < pageNav.children.length; t++){
            pageNav.children[t].className = '';
          }
          this.className = tabPage.activeClass;
          iNum = this.index;
          ini(iNum);
        };
      }
      
      
      //下一页
      pageNext.onclick = function(){
        if(iNum == len - 1){
          alert('已经是最后一页');
          return false;
        }else{
          for(var t = 0; t < pageNav.children.length; t++){
            pageNav.children[t].className = '';
          }
          iNum++;
          pageNav.children[iNum].className = tabPage.activeClass;
          ini(iNum);
        }
      };
      
      //上一页
      pagePrev.onclick = function(){
        if(iNum == 0){
          alert('当前是第一页');
          return false;
        }else{
          for(var t = 0; t < pageNav.children.length; t++){
            pageNav.children[t].className = '';
          }
          iNum--;
          pageNav.children[iNum].className = tabPage.activeClass;
          ini(iNum);
        }
      };
      
      function ini(iNum){
        for(var i = 0; i < pageMain.children.length; i++){
          pageMain.children[i].style.display = 'none';
        }
        
        for(var i = 0; i < curNum; i++){
          if(pageMain.children[(iNum * curNum + i)] == undefined){ continue; }
          pageMain.children[(iNum * curNum + i)].style.display = 'block';
        }
      }
      
      ini(iNum);
      
    }
  </script>
</html>
